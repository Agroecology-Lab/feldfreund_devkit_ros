#!/usr/bin/env python3
import os
import subprocess
import platform
import serial.tools.list_ports

# Official Hardware IDs
UBLOX_VID = 0x1546  # u-blox AG (F9P)
ESP32_VID = 0x303a  # Espressif Systems (ESP32-S3 MCU)
SEP_VID   = 0x1513  # Septentrio (Alternative GPS)

def sanitize_hardware(port):
    """The 'Sane' Reset: Kills zombies and fixes ASIO latency at the kernel level."""
    if not port or port == "virtual":
        return
    
    print(f"üõ†Ô∏è  Sanitizing {port}...")
    try:
        # 1. Kill zombie processes (fuser) - helps if a previous docker container hung
        subprocess.run(["sudo", "fuser", "-k", port], stderr=subprocess.DEVNULL)
        
        # 2. Set low latency mode (Crucial for high-frequency ROS 2 driver stability)
        subprocess.run(["sudo", "setserial", port, "low_latency"], stderr=subprocess.DEVNULL)
        
        # 3. Force baud and raw mode (460800 is standard for F9P/MCU high-speed data)
        subprocess.run(["sudo", "stty", "-F", port, "460800", "raw", "-echo"], stderr=subprocess.DEVNULL)
        
        # 4. Ensure permissions
        subprocess.run(["sudo", "chmod", "666", port], stderr=subprocess.DEVNULL)
    except Exception as e:
        print(f"‚ö†Ô∏è  Warning during sanitization of {port}: {e}")

def scan_and_export():
    print("üîé Scanning for Open Agbot Hardware...")
    
    # Identify platform
    arch = platform.machine()
    is_jetson = (arch == 'aarch64')
    
    ports = serial.tools.list_ports.comports()
    
    gps_device = None
    gps_type = "none"
    mcu_device = None

    # Precise scanning based on Vendor ID
    for port in ports:
        if port.vid == UBLOX_VID:
            gps_device = port.device
            gps_type = "ublox"
            print(f"‚úÖ Found u-blox GPS: {gps_device}")
        elif port.vid == SEP_VID:
            gps_device = port.device
            gps_type = "septentrio"
            print(f"‚úÖ Found Septentrio GPS: {gps_device}")
        elif port.vid == ESP32_VID:
            mcu_device = port.device
            print(f"‚úÖ Found ESP32 MCU:  {mcu_device}")

    # SBC Fallback: If no USB MCU found and we are on Jetson, use the header
    if not mcu_device and is_jetson:
        mcu_device = "/dev/ttyTHS0"
        print(f"‚ÑπÔ∏è  No USB MCU found. Falling back to Jetson Header: {mcu_device}")

    # ACTIVE SANITIZATION
    if gps_device:
        sanitize_hardware(gps_device)
    if mcu_device and mcu_device != "/dev/ttyTHS0":
        sanitize_hardware(mcu_device)

    # Final logic for .env
    env_gps_port = gps_device if gps_device else "virtual"
    env_mcu_port = mcu_device if mcu_device else "virtual"
    
    # Determine Status Strings
    gps_status = f"‚úÖ {gps_type.upper()} ({env_gps_port})" if gps_device else "üëª GHOST"
    mcu_status = f"‚úÖ FOUND ({env_mcu_port})" if mcu_device else "üëª GHOST"
    
    print(f"MCU Status: {mcu_status}")
    print(f"GPS Status: {gps_status}")

    # Write to .env
    env_path = os.path.join(os.getcwd(), ".env")
    try:
        with open(env_path, "w") as f:
            f.write("# Auto-generated by fixusb.py\n")
            f.write(f"GPS_PORT={env_gps_port}\n")
            f.write(f"GPS_TYPE={gps_type}\n")
            f.write(f"MCU_PORT={env_mcu_port}\n")
            f.write(f"USER_ID={os.getuid()}\n")
            f.write(f"GROUP_ID={os.getgid()}\n")
            f.write(f"IS_JETSON={'true' if is_jetson else 'false'}\n")
        print(f"‚ú® .env file updated successfully at {env_path}")
    except Exception as e:
        print(f"‚ùå Failed to write .env file: {e}")

if __name__ == "__main__":
    scan_and_export()
