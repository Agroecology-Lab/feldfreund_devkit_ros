diff --git a/manage.py b/manage.py
index 9400c27..537bc39 100755
--- a/manage.py
+++ b/manage.py
@@ -1,140 +1,154 @@
 #!/usr/bin/env python3
-import argparse
-import os
 import subprocess
+import os
 import sys
-import time
-from pathlib import Path
 
 # Project configuration
 IMAGE_NAME = 'feldfreund:jazzy'
 CONTAINER_NAME = 'feldfreund_runtime'
-
-def log(msg: str):
-    print(f'[MNG] {msg}')
+ROS_DISTRO = 'jazzy'
 
 def prepare_workspace():
-    """Simple symlink management for host-side IDE support (Intellisense)."""
-    root = Path.cwd()
-    src_dir = root / 'src'
+    '''Ensures src exists and heals package structure for ROS 2 Jazzy.'''
+    workspace_root = os.getcwd()
+    src_dir = os.path.join(workspace_root, 'src')
     packages = ['devkit_driver', 'devkit_launch', 'devkit_ui']
-    
-    src_dir.mkdir(exist_ok=True)
+
+    # Alignment of misplaced launch files
+    ui_launch_dir = os.path.join(workspace_root, 'devkit_ui', 'launch')
+    misplaced_ui = os.path.join(workspace_root, 'devkit_launch', 'launch', 'ui.launch.py')
+    correct_ui = os.path.join(ui_launch_dir, 'ui.launch.py')
+    ui_setup_py = os.path.join(workspace_root, 'devkit_ui', 'setup.py')
+
+    if not os.path.exists(ui_launch_dir):
+        print(f'Creating directory: {ui_launch_dir}')
+        os.makedirs(ui_launch_dir, exist_ok=True)
+
+    if os.path.exists(misplaced_ui) and not os.path.exists(correct_ui):
+        print('Moving ui.launch.py to devkit_ui/launch...')
+        os.rename(misplaced_ui, correct_ui)
+
+    # Patching setup.py for proper ROS 2 indexing
+    if os.path.exists(ui_setup_py):
+        with open(ui_setup_py, 'r') as f:
+            content = f.read()
+        
+        old_path = "os.path.join('share', package_name)"
+        new_path = "os.path.join('share', package_name, 'launch')"
+        
+        if old_path in content and new_path not in content:
+            print(f'Patching {ui_setup_py}...')
+            new_content = content.replace(old_path, new_path)
+            with open(ui_setup_py, 'w') as f:
+                f.write(new_content)
+
+    # Symlink management for Docker mount
+    os.makedirs(src_dir, exist_ok=True)
     for pkg in packages:
-        pkg_path = root / pkg
-        link_path = src_dir / pkg
-        if not link_path.exists() and pkg_path.exists():
-            log(f"Linking {pkg} for IDE visibility...")
-            os.symlink(Path('..') / pkg, link_path)
-
-def run_build(full_clean=False):
-    """Builds the Docker image and extracts the bundled install folder."""
+        pkg_path = os.path.join(workspace_root, pkg)
+        link_path = os.path.join(src_dir, pkg)
+        
+        if os.path.islink(link_path):
+            os.remove(link_path)
+        elif os.path.exists(link_path):
+            subprocess.run(['sudo', 'rm', '-rf', link_path], check=True)
+
+        if os.path.exists(pkg_path):
+            print(f'Linking {pkg} -> src/{pkg}')
+            os.symlink(os.path.join('..', pkg), link_path)
+        else:
+            print(f'Warning: {pkg} not found on host!')
+
+def run_build(full=False):
+    '''Builds Docker image and extracts artifacts to the host.'''
     prepare_workspace()
     
-    if full_clean:
-        log('Purging local build artifacts...')
+    if full:
+        print('Purging build artifacts (build/install/log)...')
         subprocess.run(['sudo', 'rm', '-rf', 'build/', 'install/', 'log/'], check=False)
     
     build_cmd = ['docker', 'build', '-t', IMAGE_NAME, '-f', 'docker/Dockerfile', '.']
-    if full_clean:
+    if full:
         build_cmd.insert(2, '--no-cache')
     
     try:
         subprocess.run(build_cmd, check=True)
-        log('Extracting build artifacts for host Intellisense...')
+        print('Extracting internal build to host...')
         subprocess.run(['docker', 'rm', '-f', 'temp_extract'], capture_output=True)
         subprocess.run(['docker', 'create', '--name', 'temp_extract', IMAGE_NAME], check=True)
         subprocess.run(['docker', 'cp', 'temp_extract:/workspace/install', '.'], check=True)
         subprocess.run(['docker', 'rm', 'temp_extract'], check=True)
         
-        # Ensure your host user owns the extracted files so you can edit/read them
-        subprocess.run(['sudo', 'chown', '-R', f'{os.getuid()}:{os.getgid()}', 'install/'], check=True)
-        log('Build complete.')
-    except subprocess.CalledProcessError as e:
-        log(f'Build failed: {e}')
+        user_info = f'{os.getuid()}:{os.getgid()}'
+        subprocess.run(['sudo', 'chown', '-R', user_info, 'install/'], check=True)
+        print('Build and Extraction Complete.')
+        
+    except subprocess.CalledProcessError:
+        print('Build failed.')
         sys.exit(1)
 
-def run_runtime(extra_args, sowbot_enabled=False):
-    """Executes the runtime with environment isolation and hardware resilience."""
-    
-    # 1. Environment Isolation: Block host ROS paths from leaking into Docker
-    # This prevents the 'librmw_cyclonedds_cpp.so' not found error
-    clean_env = {k: v for k, v in os.environ.items() if not k.startswith(('ROS_', 'RMW_', 'AMENT_'))}
+def run_runtime(extra_args):
+    '''Prepares hardware and executes the ROS 2 runtime environment.'''
+    if os.path.exists('fixusb.py'):
+        subprocess.run(['python3', 'fixusb.py'], check=True)
 
-    # 2. Hardware Mapping from .env
-    env_file = Path('.env')
     ports = {}
-    if env_file.exists():
-        for line in env_file.read_text().splitlines():
-            if '=' in line and not line.startswith('#'):
-                k, v = line.strip().split('=', 1)
-                ports[k.strip()] = v.strip()
-
-    mcu_p = ports.get('MCU_PORT', 'virtual')
-    r_port = ports.get('GPS_PORT_ROVER', 'virtual')
+    if os.path.exists('.env'):
+        with open('.env', 'r') as f:
+            for line in f:
+                if '=' in line and not line.startswith('#'):
+                    k, v = line.strip().split('=', 1)
+                    ports[k.strip()] = v.strip()
+    
+    # Port retrieval from environment
+    r_port  = ports.get('GPS_PORT_ROVER', 'virtual')
     r1_port = ports.get('GPS_PORT_ROVER1', 'virtual')
-    r_type = ports.get('GPS_TYPE_ROVER', 'none')
+    mcu_p   = ports.get('MCU_PORT', 'virtual')
+    r_type  = ports.get('GPS_TYPE_ROVER', 'none')
     r1_type = ports.get('GPS_TYPE_ROVER1', 'none')
 
-    is_virtual = (mcu_p == 'virtual')
-    sim_flag = 'sim:=true' if is_virtual else 'sim:=false'
+    is_virtual = (r_port == 'virtual' and mcu_p == 'virtual')
+    sowbot_enabled = 'true' if any('sowbot:=true' in arg for arg in extra_args) else 'false'
 
-    # 3. Resilient Hardware Prep (The "Anti-Ghost" loop)
+    # Hardware sanitisation
     if not is_virtual:
         for p in [r_port, r1_port, mcu_p]:
             if p and p.startswith('/dev/'):
-                for i in range(1, 6):
-                    if Path(p).exists():
-                        subprocess.run(['sudo', 'chmod', '666', p], check=False)
-                        break
-                    log(f'Waiting for hardware {p} ({i}/5)...')
-                    time.sleep(1)
+                subprocess.run(['sudo', 'chmod', '666', p], check=False)
         
-        if Path(mcu_p).exists():
-            # Wake up Lizard firmware (ESP32)
-            subprocess.run(f"stty -F {mcu_p} 115200 && (echo 's' > {mcu_p} &)", shell=True)
-
-    # 4. Construct Command (Leveraging Docker ENTRYPOINT)
-    # The Dockerfile ENTRYPOINT handles the ROS plumbing; we just provide the launch command.
-    ros_launch_cmd = (
-        f"ros2 launch devkit_launch devkit.launch.py "
-        f"{sim_flag} sowbot:={'true' if sowbot_enabled else 'false'} "
-        f"mcu_port:={mcu_p} rover_port:={r_port} rover_type:={r_type} "
-        f"rover1_port:={r1_port} rover1_type:={r1_type} "
-        f"{' '.join(extra_args)}"
-    )
-
-    docker_cmd = [
+        if mcu_p.startswith('/dev/'):
+            stty_cmd = f"stty -F {mcu_p} 115200 && (echo 's' > {mcu_p} &)"
+            os.system(stty_cmd)
+
+    if not os.path.exists('install/setup.bash'):
+        print('Error: install/setup.bash not found. Run ./manage.py build first.')
+        return
+
+    sim_flag = 'sim:=true' if is_virtual else 'sim:=false'
+    setup_cmd = f'source /opt/ros/{ROS_DISTRO}/setup.bash && source install/setup.bash'
+    
+    # Docker execution with hardware passthrough
+    cmd = [
         'docker', 'run', '-it', '--rm', '--name', CONTAINER_NAME,
         '--net=host', '--privileged',
-        '--env-file', str(env_file) if env_file.exists() else '/dev/null',
+        '--env-file', '.env' if os.path.exists('.env') else '/dev/null',
         '-v', '/dev:/dev', '-v', f'{os.getcwd()}:/workspace', '-w', '/workspace',
-        IMAGE_NAME, '/bin/bash', '-c', ros_launch_cmd
+        IMAGE_NAME, '/bin/bash', '-c',
+        f'{setup_cmd} && ros2 launch devkit_launch devkit.launch.py '
+        f'{sim_flag} '
+        f'rover_port:={r_port} rover_type:={r_type} '
+        f'rover1_port:={r1_port} rover1_type:={r1_type} '
+        f'mcu_port:={mcu_p} sowbot:={sowbot_enabled} {" ".join(extra_args)}'
     ]
-
-    log(f"Launching (Sim: {is_virtual}, Sowbot: {sowbot_enabled})")
-    try:
-        # We pass clean_env to ensure the docker process itself is isolated from host ROS vars
-        subprocess.run(docker_cmd, env=clean_env)
-    except KeyboardInterrupt:
-        log('User-initiated shutdown.')
+    subprocess.run(cmd)
 
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Feldfreund DevKit Manager')
-    parser.add_argument('command', choices=['build', 'up', 'clean'], nargs='?', default='up')
-    parser.add_argument('--sowbot', action='store_true', help='Enable sowbot hardware logic')
-    parser.add_argument('--full', action='store_true', help='Full clean build with no cache')
-    parser.add_argument('extra', nargs=argparse.REMAINDER, help='Extra ROS 2 launch arguments')
-
-    args = parser.parse_args()
-
-    if args.command == 'clean' or args.full:
-        run_build(full_clean=True)
-    elif args.command == 'build':
-        run_build(full_clean=False)
+    build_triggers = ['build', 'full-build']
+    needs_build = not os.path.exists('install/setup.bash') or any(arg in sys.argv for arg in build_triggers)
+    
+    if needs_build:
+        run_build('full-build' in sys.argv)
     
-    if args.command == 'up' or not sys.argv[1:]:
-        if not Path('install/setup.bash').exists():
-            log('No install folder found. Initiating build...')
-            run_build(full_clean=args.full)
-        run_runtime(args.extra, sowbot_enabled=args.sowbot)
+    if not any(arg in build_triggers for arg in sys.argv) or 'up' in sys.argv:
+        launch_args = [arg for arg in sys.argv[1:] if arg not in build_triggers and arg != 'up']
+        run_runtime(launch_args)
